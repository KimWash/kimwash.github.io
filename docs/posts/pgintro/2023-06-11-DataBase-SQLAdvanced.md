---
layout: post
title: "데이터베이스: SQL 고급"
category: CS
date: "2023-06-11 00:07:00"
---

## 숫자

- ABS
- ROUND(value, n): 소수점 n번째 자리까지 반올림

## 문자열

- REPLACE(origin, textBeReplaced, textToReplace): origin의 textBeReplaced를 textToReplace로 치환
- LENGTH: 바이트 수
- CHAR_LENGTH: 글자수 (바이트수 X)
- SUBSTR(origin, start, length): origin 문자열을 start 부터 length 개 문자를 반환

## 날짜

- ADDDATE(date, interval): date에서 interval 만큼 더한 날짜를 반환
- SYSDATE: DBMS 시스템 상 현재 날짜 반환
- DATE_FORMAT(date, format): 날짜형 데이터를 문자열로 반환

## NULL값 처리

- 0, ‘0’, ‘’, ‘ ‘ 등과 다른 특별한 값
- 비교 연산자로 비교 불가능
- NULL값에 연산 수행하면 결과 역시 NULL로 반환
- IFNULL: NULL을 다른 값으로 치환해 연산하거나 다른 값으로 출력
- IS NULL / IS NOT NULL: 널인지 체크 (’=’ 안됨)

### 집계 함수를 사용할 때 주의할 점

- 집계 함수 계산 시 NULL이 포함된 행은 집계에서 빠짐
    - 모든 데이터가 NULL → SUM, AVG 함수의 결과: NULL, COUNT:0

## 부속질의 (subquery)

- 하나의 SQL 문 안에 다른 SQL 문이 중첩된 질의
- 다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용
- 데이터가 대량일 때 데이터를 모두 합쳐서 연산하는 조인보다 필요한 데이터만 찾아서 공급해주는 부속질의가 성능이 더 좋음
- 종류
    - 스칼라 부속질의: SELECT 절에서 단일 값을 반환
    - 인라인 뷰: FROM 절에서 결과를 뷰(view) 형태로 반환
        - 상관 부속질의로 사용될 수 없음
        - 상관 부속질의란 주질의의 특정 컬럼 값을 부속질의가 상속받아 사용하는 형태
        - 조인에 참여하기 전 필요한 데이터만 뽑아 조인시켜 성능 향상 가능
- 중첩질의: WHERE 절에서 술어와 같이 사용, 결과를 한정시키기 위해 상관/비상관 혀앹로 사용됨

## 뷰(view)

- 하나 이상의 테이블을 합하여 만든 가상의 테이블
- 실제 테이블이 아닌 뷰를 생성할 때 SELECT 문의 정의를 DBMS가 저장, 뷰를 사용할 때 질의
- 조건을 만족하는 튜플만 보여주는 View

### 뷰의 생성

- `CREATE VIEW 뷰이름 [(열이름 [ ,...n ])] AS SELECT문`

```sql
SELECT * FROM BookWHERE bookname LIKE '%축구%';
```

```sql
CREATE VIEW vw_Book 
AS SELECT * FROM Book WHERE bookname LIKE '%축구%';
```

### 뷰의 수정

- `CREATE OR REPLACE VIEW 뷰이름 [(열이름 [ ,...n ])} AS SELECT 문;`

### 뷰의 삭제

- `DROP VIEW 뷰이름 [ ,...n ];`

## 인덱스

- 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조
- `CREATE INDEX ix_Book ON Book (bookname);`
- `SHOW INDEX FROM Book;`
- 튜플의 키 값에 대한 위치
- 생성 시 고려사항
    - WHERE 절/조인에 자주 사용되는 속성
    - 단일 테이블에 인덱스가 많으면 속도가 느려질 수 있음 (4-5개 권장)
    - 속성이 가공되는 경우 사용 X
    - 선택도(=1/서로 다른 값의 개수)가 낮을 때 유리함
- 인덱스는 B(alanced)-Tree 자료구조를 이용. 데이터의 수정/삭제/삽입이 잦으면 노드의 갱신이 주기적으로 일어나 단편화(fragmentation) 현상이 나타남 → 검색 시 성능 저하 발생
- `ANALYZE TABLE 테이블이름;` 명령을 이용해 인덱스를 재생성
- `DROP INDEX 인덱스이름 ON 테이블이름;`

## 이상현상

- 불필요한 데이터의 중복으로 인해 릴레이션에 대한 데이터의 삽입/수정/삭제 연산을 수행할 때 발생할 수 있는 부작용
    - 삭제이상: 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
    - 수정이상: 튜플 수정시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상
    - 삽입이상: 튜플 삽입 시 특정 속성에 해당되는 값이 없어 NULL 값을 입력해야 하는 현상

## 함수 종속

- “X가 Y를 함수적으로 결정한다”
    - 릴레이션 내의 모든 튜플에서 하나의 X 값에 대한 Y 값이 항상 하나임
    - X와 Y는 하나의 릴레이션을 구성하는 속성들의 부분 집합
    - “Y가 X에 함수적으로 종속되어 있다"와 같은 의미
    - X→ Y로 표현 (X는 결정자, Y는 종속자)
- 함수적 종속성, 속성들 간의 관련성
- 이상형상이 발생하지 않도록 릴레이션을 관련 있는 속성들로만 구성하기 위해 릴레이션을 분해하는 정규화 과정에 함수적 종속성을 판단
- 함수 종속 관계 판단 시 유의사항
    - 속성 값이 아닌 “속성 자체의 특성”을 고려하여 함수 종속 관계를 판단해야 함
    - 기본키는 종속성 판단에서 제외
    - 기본키/후보키가 아니어도 릴레이션의 다른 속성을 유일하게 결정하는 속성은 함수 종속 관계에서 결정자가 될 수 있음
- 완전 함수 종속
    - 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 X의 전체가 아닌 일부분에는 종속되지 않음
    - 일반적으로 함수 종속은 완전 함수 종속을 의미
    - ex) 당첨여부는 {고객아이디, 이벤트번호} 에 완전 함수 종속
- 부분 함수 종속
    - 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 종속
    - 결정자가 여러 개의 속성들로 구성돼있어야 함
    - ex) 고객이름은 {고객아이디, 이벤트번호}에 부분 함수 종속됨 (고객이름은 고객아이디에 완전 함수 종속)
- 함수 종속 규칙

X,Y,Z가 릴레이션 R에 포함된 속성의 집합이라고 할 때, 함수 종속에 관한 다음 규칙이 성립

1. 부분집합 규칙: if Y $\subseteq$ X, then X → Y
2. 증가 규칙: if X → Y, then XZ → YZ
3. 이행 규칙: if X → Y, Y → Z, then X → Z

위 세 가지 규칙으로 부터 부가적인 다음 규칙들을 얻을 수 있음

1. 결합 규칙: if X → Y and X → Z, then X → YZ
2. 분해 규칙: if X → YZ, then X → Y and X → Z
3. 유사이행 규칙: If X → Y and WY → Z, then WX → Z